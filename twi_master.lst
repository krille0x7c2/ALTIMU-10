   1               		.file	"twi_master.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 104               	.global	TWIInit
 106               	TWIInit:
   1:twi_master.c  **** /* 
   2:twi_master.c  ****  * File:   twi_master.c
   3:twi_master.c  ****  * Author: Christian Bodelsson<bodelsson@gmail.com>
   4:twi_master.c  ****  * source: http://www.atmel.com/images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA
   5:twi_master.c  ****  * Created on February 16, 2015, 6:23 PM
   6:twi_master.c  ****  */
   7:twi_master.c  **** #include "ALTIMU_10.h"
   8:twi_master.c  **** #include <avr/io.h>
   9:twi_master.c  **** #include "twi_master.h"
  10:twi_master.c  **** #include <inttypes.h>
  11:twi_master.c  **** #include <compat/twi.h>
  12:twi_master.c  **** #include <util/delay.h>
  13:twi_master.c  **** void TWIInit(void)
  14:twi_master.c  **** {
 108               	.LM0:
 109               	.LFBB1:
 110               	/* prologue: function */
 111               	/* frame size = 0 */
 112               	/* stack size = 0 */
 113               	.L__stack_usage = 0
  15:twi_master.c  ****     //set SCL to 400kHz
  16:twi_master.c  ****     TWSR = 0x00;
 115               	.LM1:
 116 0000 1092 B900 		sts 185,__zero_reg__
  17:twi_master.c  ****     TWBR = 0x0C;
 118               	.LM2:
 119 0004 8CE0      		ldi r24,lo8(12)
 120 0006 8093 B800 		sts 184,r24
  18:twi_master.c  ****     //enable TWI
  19:twi_master.c  ****     TWCR = (1<<TWEN);
 122               	.LM3:
 123 000a 84E0      		ldi r24,lo8(4)
 124 000c 8093 BC00 		sts 188,r24
 125 0010 0895      		ret
 127               	.Lscope1:
 130               	.global	i2c_start
 132               	i2c_start:
  20:twi_master.c  **** }
  21:twi_master.c  **** /*************************************************************************	
  22:twi_master.c  ****   Issues a start condition and sends address and transfer direction.
  23:twi_master.c  ****   return 0 = device accessible, 1= failed to access device
  24:twi_master.c  **** *************************************************************************/
  25:twi_master.c  **** uint8_t i2c_start(unsigned char address)
  26:twi_master.c  **** {
 134               	.LM4:
 135               	.LFBB2:
 136               	/* prologue: function */
 137               	/* frame size = 0 */
 138               	/* stack size = 0 */
 139               	.L__stack_usage = 0
  27:twi_master.c  ****     uint8_t   twst;
  28:twi_master.c  **** 
  29:twi_master.c  **** 	// send START condition
  30:twi_master.c  **** 	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 141               	.LM5:
 142 0012 94EA      		ldi r25,lo8(-92)
 143 0014 9093 BC00 		sts 188,r25
 144               	.L3:
  31:twi_master.c  **** 
  32:twi_master.c  **** 	// wait until transmission completed
  33:twi_master.c  **** 	while(!(TWCR & (1<<TWINT)));
 146               	.LM6:
 147 0018 9091 BC00 		lds r25,188
 148 001c 97FF      		sbrs r25,7
 149 001e 00C0      		rjmp .L3
  34:twi_master.c  **** 
  35:twi_master.c  **** 	// check value of TWI Status Register. Mask prescaler bits.
  36:twi_master.c  **** 	twst = TW_STATUS & 0xF8;
 151               	.LM7:
 152 0020 9091 B900 		lds r25,185
 153 0024 987F      		andi r25,lo8(-8)
  37:twi_master.c  **** 	if ( (twst != TW_START) && (twst != TW_REP_START)) return 1;
 155               	.LM8:
 156 0026 9830      		cpi r25,lo8(8)
 157 0028 01F0      		breq .L4
 159               	.LM9:
 160 002a 9031      		cpi r25,lo8(16)
 161 002c 01F0      		breq .L4
 162               	.L7:
 164               	.LM10:
 165 002e 81E0      		ldi r24,lo8(1)
 166 0030 0895      		ret
 167               	.L4:
 168               	.LBB4:
 169               	.LBB5:
  38:twi_master.c  **** 
  39:twi_master.c  **** 	// send device address
  40:twi_master.c  **** 	TWDR = address;
 171               	.LM11:
 172 0032 8093 BB00 		sts 187,r24
  41:twi_master.c  **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 174               	.LM12:
 175 0036 84E8      		ldi r24,lo8(-124)
 176 0038 8093 BC00 		sts 188,r24
 177               	.L6:
  42:twi_master.c  **** 
  43:twi_master.c  **** 	// wail until transmission completed and ACK/NACK has been received
  44:twi_master.c  **** 	while(!(TWCR & (1<<TWINT)));
 179               	.LM13:
 180 003c 8091 BC00 		lds r24,188
 181 0040 87FF      		sbrs r24,7
 182 0042 00C0      		rjmp .L6
  45:twi_master.c  **** 
  46:twi_master.c  **** 	// check value of TWI Status Register. Mask prescaler bits.
  47:twi_master.c  **** 	twst = TW_STATUS & 0xF8;
 184               	.LM14:
 185 0044 8091 B900 		lds r24,185
 186 0048 887F      		andi r24,lo8(-8)
  48:twi_master.c  **** 	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
 188               	.LM15:
 189 004a 8831      		cpi r24,lo8(24)
 190 004c 01F0      		breq .L8
 191 004e 8034      		cpi r24,lo8(64)
 192 0050 01F4      		brne .L7
 193               	.L8:
  49:twi_master.c  **** 
  50:twi_master.c  **** 	return 0;
 195               	.LM16:
 196 0052 80E0      		ldi r24,0
 197               	.LBE5:
 198               	.LBE4:
  51:twi_master.c  **** 
  52:twi_master.c  **** }
 200               	.LM17:
 201 0054 0895      		ret
 209               	.Lscope2:
 212               	.global	i2c_start_wait
 214               	i2c_start_wait:
  53:twi_master.c  **** 
  54:twi_master.c  **** 
  55:twi_master.c  **** /*************************************************************************
  56:twi_master.c  ****  Issues a start condition and sends address and transfer direction.
  57:twi_master.c  ****  If device is busy, use ack polling to wait until device is ready
  58:twi_master.c  ****  
  59:twi_master.c  ****  Input:   address and transfer direction of I2C device
  60:twi_master.c  **** *************************************************************************/
  61:twi_master.c  **** void i2c_start_wait(unsigned char address)
  62:twi_master.c  **** {
 216               	.LM18:
 217               	.LFBB3:
 218               	/* prologue: function */
 219               	/* frame size = 0 */
 220               	/* stack size = 0 */
 221               	.L__stack_usage = 0
  63:twi_master.c  ****     uint8_t   twst;
  64:twi_master.c  **** 
  65:twi_master.c  **** 
  66:twi_master.c  ****     while ( 1 )
  67:twi_master.c  ****     {
  68:twi_master.c  **** 	    // send START condition
  69:twi_master.c  **** 	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 223               	.LM19:
 224 0056 24EA      		ldi r18,lo8(-92)
  70:twi_master.c  ****     
  71:twi_master.c  ****     	// wait until transmission completed
  72:twi_master.c  ****     	while(!(TWCR & (1<<TWINT)));
  73:twi_master.c  ****     
  74:twi_master.c  ****     	// check value of TWI Status Register. Mask prescaler bits.
  75:twi_master.c  ****     	twst = TW_STATUS & 0xF8;
  76:twi_master.c  ****     	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
  77:twi_master.c  ****     
  78:twi_master.c  ****     	// send device address
  79:twi_master.c  ****     	TWDR = address;
  80:twi_master.c  ****     	TWCR = (1<<TWINT) | (1<<TWEN);
 226               	.LM20:
 227 0058 34E8      		ldi r19,lo8(-124)
  81:twi_master.c  ****     
  82:twi_master.c  ****     	// wail until transmission completed
  83:twi_master.c  ****     	while(!(TWCR & (1<<TWINT)));
  84:twi_master.c  ****     
  85:twi_master.c  ****     	// check value of TWI Status Register. Mask prescaler bits.
  86:twi_master.c  ****     	twst = TW_STATUS & 0xF8;
  87:twi_master.c  ****     	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
  88:twi_master.c  ****     	{    	    
  89:twi_master.c  ****     	    /* device busy, send stop condition to terminate write operation */
  90:twi_master.c  **** 	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 229               	.LM21:
 230 005a 44E9      		ldi r20,lo8(-108)
 231               	.L19:
  69:twi_master.c  ****     
 233               	.LM22:
 234 005c 2093 BC00 		sts 188,r18
 235               	.L20:
  72:twi_master.c  ****     
 237               	.LM23:
 238 0060 9091 BC00 		lds r25,188
 239 0064 97FF      		sbrs r25,7
 240 0066 00C0      		rjmp .L20
  75:twi_master.c  ****     	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
 242               	.LM24:
 243 0068 9091 B900 		lds r25,185
 244 006c 987F      		andi r25,lo8(-8)
  76:twi_master.c  ****     
 246               	.LM25:
 247 006e 9830      		cpi r25,lo8(8)
 248 0070 01F0      		breq .L21
  76:twi_master.c  ****     
 250               	.LM26:
 251 0072 9031      		cpi r25,lo8(16)
 252 0074 01F4      		brne .L19
 253               	.L21:
  79:twi_master.c  ****     	TWCR = (1<<TWINT) | (1<<TWEN);
 255               	.LM27:
 256 0076 8093 BB00 		sts 187,r24
  80:twi_master.c  ****     
 258               	.LM28:
 259 007a 3093 BC00 		sts 188,r19
 260               	.L23:
  83:twi_master.c  ****     
 262               	.LM29:
 263 007e 9091 BC00 		lds r25,188
 264 0082 97FF      		sbrs r25,7
 265 0084 00C0      		rjmp .L23
  86:twi_master.c  ****     	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
 267               	.LM30:
 268 0086 9091 B900 		lds r25,185
 269 008a 987F      		andi r25,lo8(-8)
  87:twi_master.c  ****     	{    	    
 271               	.LM31:
 272 008c 9032      		cpi r25,lo8(32)
 273 008e 01F0      		breq .L24
  87:twi_master.c  ****     	{    	    
 275               	.LM32:
 276 0090 9835      		cpi r25,lo8(88)
 277 0092 01F4      		brne .L18
 278               	.L24:
 280               	.LM33:
 281 0094 4093 BC00 		sts 188,r20
 282               	.L26:
  91:twi_master.c  **** 	        
  92:twi_master.c  **** 	        // wait until stop condition is executed and bus released
  93:twi_master.c  **** 	        while(TWCR & (1<<TWSTO));
 284               	.LM34:
 285 0098 9091 BC00 		lds r25,188
 286 009c 94FD      		sbrc r25,4
 287 009e 00C0      		rjmp .L26
 288 00a0 00C0      		rjmp .L19
 289               	.L18:
 290 00a2 0895      		ret
 292               	.Lscope3:
 295               	.global	i2c_rep_start
 297               	i2c_rep_start:
  94:twi_master.c  **** 	        
  95:twi_master.c  ****     	    continue;
  96:twi_master.c  ****     	}
  97:twi_master.c  ****     	//if( twst != TW_MT_SLA_ACK) return 1;
  98:twi_master.c  ****     	break;
  99:twi_master.c  ****      }
 100:twi_master.c  **** 
 101:twi_master.c  **** }
 102:twi_master.c  **** 
 103:twi_master.c  **** 
 104:twi_master.c  **** /*************************************************************************
 105:twi_master.c  ****  Issues a repeated start condition and sends address and transfer direction 
 106:twi_master.c  **** 
 107:twi_master.c  ****  Input:   address and transfer direction of I2C device
 108:twi_master.c  ****  
 109:twi_master.c  ****  Return:  0 device accessible
 110:twi_master.c  ****           1 failed to access device
 111:twi_master.c  **** *************************************************************************/
 112:twi_master.c  **** uint8_t i2c_rep_start(unsigned char address)
 113:twi_master.c  **** {
 299               	.LM35:
 300               	.LFBB4:
 301               	/* prologue: function */
 302               	/* frame size = 0 */
 303               	/* stack size = 0 */
 304               	.L__stack_usage = 0
 114:twi_master.c  ****     return i2c_start( address );
 306               	.LM36:
 307 00a4 0C94 0000 		jmp i2c_start
 309               	.Lscope4:
 311               	.global	i2c_stop
 313               	i2c_stop:
 115:twi_master.c  **** 
 116:twi_master.c  **** }
 117:twi_master.c  **** 
 118:twi_master.c  **** 
 119:twi_master.c  **** /*************************************************************************
 120:twi_master.c  ****  Terminates the data transfer and releases the I2C bus
 121:twi_master.c  **** *************************************************************************/
 122:twi_master.c  **** void i2c_stop(void)
 123:twi_master.c  **** {
 315               	.LM37:
 316               	.LFBB5:
 317               	/* prologue: function */
 318               	/* frame size = 0 */
 319               	/* stack size = 0 */
 320               	.L__stack_usage = 0
 124:twi_master.c  ****     /* send stop condition */
 125:twi_master.c  **** 	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 322               	.LM38:
 323 00a8 84E9      		ldi r24,lo8(-108)
 324 00aa 8093 BC00 		sts 188,r24
 325               	.L38:
 126:twi_master.c  **** 	
 127:twi_master.c  **** 	// wait until stop condition is executed and bus released
 128:twi_master.c  **** 	while(TWCR & (1<<TWSTO));
 327               	.LM39:
 328 00ae 8091 BC00 		lds r24,188
 329 00b2 84FD      		sbrc r24,4
 330 00b4 00C0      		rjmp .L38
 331               	/* epilogue start */
 129:twi_master.c  **** 
 130:twi_master.c  **** }
 333               	.LM40:
 334 00b6 0895      		ret
 336               	.Lscope5:
 339               	.global	i2c_write
 341               	i2c_write:
 131:twi_master.c  **** 
 132:twi_master.c  **** 
 133:twi_master.c  **** /*************************************************************************
 134:twi_master.c  ****   Send one byte to I2C device
 135:twi_master.c  ****   
 136:twi_master.c  ****   Input:    byte to be transfered
 137:twi_master.c  ****   Return:   0 write successful 
 138:twi_master.c  ****             1 write failed
 139:twi_master.c  **** *************************************************************************/
 140:twi_master.c  **** uint8_t i2c_write( unsigned char data )
 141:twi_master.c  **** {	
 343               	.LM41:
 344               	.LFBB6:
 345               	/* prologue: function */
 346               	/* frame size = 0 */
 347               	/* stack size = 0 */
 348               	.L__stack_usage = 0
 142:twi_master.c  ****     uint8_t   twst;
 143:twi_master.c  ****     
 144:twi_master.c  **** 	// send data to the previously addressed device
 145:twi_master.c  **** 	TWDR = data;
 350               	.LM42:
 351 00b8 8093 BB00 		sts 187,r24
 146:twi_master.c  **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 353               	.LM43:
 354 00bc 84E8      		ldi r24,lo8(-124)
 355 00be 8093 BC00 		sts 188,r24
 356               	.L41:
 147:twi_master.c  **** 
 148:twi_master.c  **** 	// wait until transmission completed
 149:twi_master.c  **** 	while(!(TWCR & (1<<TWINT)));
 358               	.LM44:
 359 00c2 8091 BC00 		lds r24,188
 360 00c6 87FF      		sbrs r24,7
 361 00c8 00C0      		rjmp .L41
 150:twi_master.c  **** 
 151:twi_master.c  **** 	// check value of TWI Status Register. Mask prescaler bits only need the top 5 bits
 152:twi_master.c  **** 	twst = TW_STATUS & 0xF8;
 363               	.LM45:
 364 00ca 9091 B900 		lds r25,185
 365 00ce 987F      		andi r25,lo8(-8)
 153:twi_master.c  **** 	if( twst != TW_MT_DATA_ACK) return 1;
 367               	.LM46:
 368 00d0 81E0      		ldi r24,lo8(1)
 369 00d2 9832      		cpi r25,lo8(40)
 370 00d4 01F4      		brne .L42
 371 00d6 80E0      		ldi r24,0
 372               	.L42:
 154:twi_master.c  **** 	return 0;
 155:twi_master.c  **** 
 156:twi_master.c  **** }
 374               	.LM47:
 375 00d8 0895      		ret
 377               	.Lscope6:
 379               	.global	i2c_readAck
 381               	i2c_readAck:
 157:twi_master.c  **** 
 158:twi_master.c  **** 
 159:twi_master.c  **** /*************************************************************************
 160:twi_master.c  ****  Read one byte from the I2C device, request more data from device 
 161:twi_master.c  ****  
 162:twi_master.c  ****  Return:  byte read from I2C device
 163:twi_master.c  **** *************************************************************************/
 164:twi_master.c  **** uint8_t i2c_readAck(void)
 165:twi_master.c  **** {
 383               	.LM48:
 384               	.LFBB7:
 385               	/* prologue: function */
 386               	/* frame size = 0 */
 387               	/* stack size = 0 */
 388               	.L__stack_usage = 0
 166:twi_master.c  **** 	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
 390               	.LM49:
 391 00da 84EC      		ldi r24,lo8(-60)
 392 00dc 8093 BC00 		sts 188,r24
 393               	.L45:
 167:twi_master.c  **** 	while(!(TWCR & (1<<TWINT)));    
 395               	.LM50:
 396 00e0 8091 BC00 		lds r24,188
 397 00e4 87FF      		sbrs r24,7
 398 00e6 00C0      		rjmp .L45
 168:twi_master.c  **** 
 169:twi_master.c  ****     return TWDR;
 400               	.LM51:
 401 00e8 8091 BB00 		lds r24,187
 170:twi_master.c  **** 
 171:twi_master.c  **** }
 403               	.LM52:
 404 00ec 0895      		ret
 406               	.Lscope7:
 408               	.global	i2c_readNak
 410               	i2c_readNak:
 172:twi_master.c  **** 
 173:twi_master.c  **** 
 174:twi_master.c  **** /*************************************************************************
 175:twi_master.c  ****  Read one byte from the I2C device, read is followed by a stop condition 
 176:twi_master.c  ****  
 177:twi_master.c  ****  Return:  byte read from I2C device
 178:twi_master.c  **** *************************************************************************/
 179:twi_master.c  **** uint8_t i2c_readNak(void)
 180:twi_master.c  **** {
 412               	.LM53:
 413               	.LFBB8:
 414               	/* prologue: function */
 415               	/* frame size = 0 */
 416               	/* stack size = 0 */
 417               	.L__stack_usage = 0
 181:twi_master.c  **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 419               	.LM54:
 420 00ee 84E8      		ldi r24,lo8(-124)
 421 00f0 8093 BC00 		sts 188,r24
 422               	.L48:
 182:twi_master.c  **** 	while(!(TWCR & (1<<TWINT)));
 424               	.LM55:
 425 00f4 8091 BC00 		lds r24,188
 426 00f8 87FF      		sbrs r24,7
 427 00fa 00C0      		rjmp .L48
 183:twi_master.c  **** 	
 184:twi_master.c  ****     return TWDR;
 429               	.LM56:
 430 00fc 8091 BB00 		lds r24,187
 185:twi_master.c  **** 
 186:twi_master.c  **** }...
 432               	.LM57:
 433 0100 0895      		ret
 435               	.Lscope8:
 437               	.Letext0:
 438               		.ident	"GCC: (GNU) 4.9.2 20141224 (prerelease)"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 twi_master.c
     /tmp/ccBFGjou.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccBFGjou.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccBFGjou.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccBFGjou.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccBFGjou.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccBFGjou.s:106    .text:0000000000000000 TWIInit
     /tmp/ccBFGjou.s:132    .text:0000000000000012 i2c_start
     /tmp/ccBFGjou.s:214    .text:0000000000000056 i2c_start_wait
     /tmp/ccBFGjou.s:297    .text:00000000000000a4 i2c_rep_start
     /tmp/ccBFGjou.s:313    .text:00000000000000a8 i2c_stop
     /tmp/ccBFGjou.s:341    .text:00000000000000b8 i2c_write
     /tmp/ccBFGjou.s:381    .text:00000000000000da i2c_readAck
     /tmp/ccBFGjou.s:410    .text:00000000000000ee i2c_readNak

NO UNDEFINED SYMBOLS
